import unittest
from encoding import decode16
from falcon import PublicKey
from keccak_prng import KeccakPRNG
from polyntt.poly import Poly

class TestFalconKAT(unittest.TestCase):

    # def test_generation_KAT(self):
    #     # THIS WORKS BUT IT IS VERY SLOW BECAUSE OUR IMPLEMENTATION OF KECCAK IS SLOWER THAN PYCRYPTODOME.
    #     """
    #     Test the signing procedure against test vectors obtained from
    #     the Round 3 implementation of Falcon.

    #     Starting from the same private key, same message, and same SHAKE256
    #     context (for randomness generation), we check that we obtain the
    #     same signatures.
    #     """
    #     message = b"data1"
    #     shake = SHAKE.new(b"external")
    #     shake.flip()
    #     for n in sign_KAT:
    #         sign_KAT_n = sign_KAT[n]
    #         for D in sign_KAT_n:
    #             f = D["f"]
    #             g = D["g"]
    #             F = D["F"]
    #             G = D["G"]
    #             print(1)
    #             sk = SecretKey(n, [f, g, F, G])
    #             print(2)
    #             # The next line is done to synchronize the SHAKE256 context
    #             # with the one in the Round 3 C implementation of Falcon.
    #             _ = shake.read(8 * D["read_bytes"])
    #             print(3)
    #             sig = sk.sign(message, shake.read, xof=SHAKE)
    #             print(4)
    #             if sig != bytes.fromhex(D["sig"]):
    #                 self.assertTrue(False)
    #     self.assertTrue(True)

    '''
    def test_verification_KAT(self):
        """
        Test the verification procedure against test vectors obtained from
        the Round 3 implementation of Falcon.

        Starting from the same public key and message, we check that the
        signature passes the verification.
        """
        message = b"data1"
        for n in sign_KAT:
            sign_KAT_n = sign_KAT[n]
            for D in sign_KAT_n:
                f = D["f"]
                g = D["g"]
                F = D["F"]
                G = D["G"]
                sk = SecretKey(n, [f, g, F, G])
                pk = PublicKey(n, sk.h)
                sig = bytes.fromhex(D["sig"])
                self.assertTrue(pk.verify(message, sig, xof=SHAKE))
    '''

    def test_KAT_ETH(self):
        """
        Test the consistency between the C reference code with Keccak PRNG and our python implementation
        """
        count = 0
        seed = bytes.fromhex("061550234D158C5EC95595FE04EF7A25767F2E24CC2BC479D09D86DC9ABCFDE7056A8C266F9EF97ED08541DBD2E1FFA1")
        mlen = 33
        pk = bytes.fromhex("096BA86CB658A8F445C9A5E4C28374BEC879C8655F68526923240918074D0147C03162E4A49200648C652803C6FD7509AE9AA799D6310D0BD42724E0635920186207000767CA5A8546B1755308C304B84FC93B069E265985B398D6B834698287FF829AA820F17A7F4226AB21F601EBD7175226BAB256D8888F009032566D6383D68457EA155A94301870D589C678ED304259E9D37B193BC2A7CCBCBEC51D69158C44073AEC9792630253318BC954DBF50D15028290DC2D309C7B7B02A6823744D463DA17749595CB77E6D16D20D1B4C3AAD89D320EBE5A672BB96D6CD5C1EFEC8B811200CBB062E473352540EDDEF8AF9499F8CDD1DC7C6873F0C7A6BCB7097560271F946849B7F373640BB69CA9B518AA380A6EB0A7275EE84E9C221AED88F5BFBAF43A3EDE8E6AA42558104FAF800E018441930376C6F6E751569971F47ADBCA5CA00C801988F317A18722A29298925EA154DBC9024E120524A2D41DC0F18FD8D909F6C50977404E201767078BA9A1F9E40A8B2BA9C01B7DA3A0B73A4C2A6B4F518BBEE3455D0AF2204DDC031C805C72CCB647940B1E6794D859AAEBCEA0DEB581D61B9248BD9697B5CB974A8176E8F910469CAE0AB4ED92D2AEE9F7EB50296DAF8057476305C1189D1D9840A0944F0447FB81E511420E67891B98FA6C257034D5A063437D379177CE8D3FA6EAF12E2DBB7EB8E498481612B1929617DA5FB45E4CDF893927D8BA842AA861D9C50471C6D0C6DF7E2BB26465A0EB6A3A709DE792AAFAAF922AA95DD5920B72B4B8856C6E632860B10F5CC08450003671AF388961872B466400ADB815BA81EA794945D19A100622A6CA0D41C4EA620C21DC125119E372418F04402D9FA7180F7BC89AFA54F8082244A42F46E5B5ABCE87B50A7D6FEBE8D7BBBAC92657CBDA1DB7C25572A4C1D0BAEA30447A865A2B1036B880037E2F4D26D453E9E913259779E9169B28A62EB809A5C744E04E260E1F2BBDA874F1AC674839DDB47B3148C5946DE0180148B7973D63C58193B17CD05D16E80CD7928C2A338363A23A81C0608C87505589B9DA1C617E7B70786B6754FBB30A5816810B9E126CFCC5AA49326E9D842973874B6359B5DB75610BA68A98C7B5E83F125A82522E13B83FB8F864E2A97B73B5D544A7415B6504A13939EAB1595D64FAF41FAB25A864A574DE524405E878339877886D2FC07FA0311508252413EDFA1158466667AFF78386DAF7CB4C9B850992F96E20525330599AB601D454688E294C8C3E")
        sk = bytes.fromhex("59044102F3CFBE1BE03C144102F7EF75FBEF83043F7CFC20C20BEEC007DE3F041FBF0BFF401041030C40040FAE7E103F7E100085FC013D1410C80C2F000810461C2F480BEE8017D17F07F1411BA24013C1BDF83DC407D17E07C13917F0F9044045FC40BD0FF07D07EF0003DFC1F3CFFD1FC03FEFC0B8FC6E7B0BBDBD0FE0BE17D14307EFFE0FBFC6F81FBFF43EC1F87041D42083EC3DC2F4407BF84EC4140FC403F037F3FEC013E0FEE02180082F83FBE07BFFE043F40EC6FFB1BF200007FFBFFA0FFF6FFBCE83EBFEBEFC0FFDF3F103FC6F3FF0500A18718308007D03F200E4213BF04FFD17D000F0017A17F180E04FFF07DEC2244048148E8704503EE06F86080243F81FFF03BF4003F07EF3DE02FBFFC00420C1F40FBDF0707E043FF5FFD0000430400C4F49F4207C142F80EC3E010BFF7C13F07FF85F7F17E07C17FF33FC4EC303FFBCFFEEC41830FF0831BDF45F05F06FC503B0C0F84E4013E100E7E1441450C2FBEEBC0C0FBEFC60BCFFEF3CFBDF4303EF800BF2BE0BF001F01F43F41FFE08517B001141E00144F7EF8007CEBDFFFF4213A0B9F8A0FE04103C17E0820BB1C30C30C00FFFFC00007D18017CFF90C3101E7E103040FC4FBE04213E07AF80FFEFC80FBFBD0810BCFB8FBC087FB8FFF1010C2E81002F3EF3BF01F07E41FBC07F2C0FB8F43F401C5D81FFCEBE07C07E0BF17EEBEE830C514003FF7EF3E08403D1FFFFE105F840C20BDF0607FFFEF46E7EFFF08000400DE830000F3F82EF9D82E84EFFF3CEC4E81E01002103102EFC080F3B0801041BAE42F7F040F83EC31010031BC0410FAFF9F0004010133A089FFEF7BE8317A0020FEF010052BA04107E100F821C2F41F44F4EF7B000F02E41F82F380830FE08A1F707FF82EC7F42E81004041103E8307B13D0FDFF8F830F9FC5FFCD7E040F410FFFB9F423750860C11C5FFA144EC0080F02DC0F420820450790020BCF80EFFFBCEC4FBFF4200AFC00C02060C004303EF81FFA104107E4117AF01F81202FC1E44143FFE206EB3E881BB13F13920403FF7A000144102E7FFC2143E7FF4AF3F13F07E181DC317E240F4500303F2DDDCF1E1513E3EF15E8DC1309E50AEE03EFDC17081706FD03E6ECE4F30EBD1909051906E90CE806EB0B19E719EFFBF10D0DF1DC0CF6F1F4F8FEFBE9F9550E2107FCDCCBDFE9F4F7EE1AF8142115F910002AF2F5FF141ADA220AECFE040CEF0B29EB201930F2D3E401E5DEEFF4DDEA17F1FE141217F81C36050109F8F61F02DD19F90310C7F40208E9052C3942F8FFF2CCF9FDF83CFA12DC091C0D02F00411F5281E40D7F92DBA11D73D04C10BFD13E617110AF3ED05F6CFE705E0F70E1FF80533FC120C002CE81FF52638190FE3FED6F0FBBB23E6F408EF32220B13DD27F007E5FA00D72614F0E302210707EC111E070E2A032DF91DE3FCE800F1F9F2F7FE170101180412CBD1E90019F2011522DAEAED13F8E5F425DCEF24E01CE614E7DCEC01F2F4F914F4010107ED26E2E9DF0BF5F007EA07FAFBC6D7E607FAFCFD270DFD0D17FC4EF0EE00071AECDE09F8F215E113F80209CCF308D7E6251ECE0EDFED0CC9F4050B2714F61BF703F0EBF104010DEBFBF21AFC1BF01823FEDEFAF7F807E3F3020AEB01FE19EEE8E90D00E5FAED1EFDF628E5F0E6F0FC13F4FB05FB0B09EA0A0E08EE13293212E90CE4FEF223F4FF030BEBED1B402ED2F6171102BC0CF9E9F335ED0C01FAF0FEFAE41DF0050A162C11171CD90BEE211218EDFAFA0F03F4171412F319D60B01FAEE1F2823F0D6EF12D6DFEAFBFC170DECDA06E7CED500031E")
        smlen = 11000
        sm = bytes.fromhex("040133B3C07507E4201748494D832B6EE2A6C93BFF9B0EE343B550D1F85A3D0DE0D704C6D17842951309D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8292FD42EF7006B2FF12FDD0053007C2FCB004D2EFD011F2F392FF5004B2FD42FAE00EB2F9300402EC72F0F00482FC800072FC72F4C012B0032008A2F9801192F8F00CE2F692F7600E000572F342FE200512E6A2F3B00DF2FE42F8C00BA2F6C2FEB2EE52F16000C2F8800A1010700CC001F001E00BD0065008C005E2FF72F8D2FF9008C00932F642FE801062F892F5700250106006D0015004A2F242FD72FE22FF62F3E2FA22F392FAF001701702FA900F72FB32F6D2FF92EED2FC7005D2FC400972F902F3000212FB501522FFA2F9D002600AA2F4E00672FDD00382FE82FCC00892EA800032FCD00CF2F6D012230002F6A2FF500482F5D2F17011800142EF92FAF2F2A00000035020A003E2EF4010B002300072FA92F9E000C2F112F6F00472FAF2F342F762FB700802F6200572FA4005F001D00022F7B2F802F402FC300EE2F8400F5002F002E2FA700A4009F2FE700F300CE005D00622F952FDA001A2F94006B2EC0005C000E2FF500132FD9001F00DE2F622F8C000E2FBA2FAB2EDB006300342FE72FC92F352EF42EC000C32E592F3B2F2100932FE12FFC2FEB01952F442FD42FAB2FF52F892F422F132F83009B00902F8200262FBE009800132EDB2FCC00AD00392EE52F9A005100E0004F2E812EE300182FAE00B82F7C2F6C2FED009D00022F5902AC00212FDE002200A1007E002A000E00C92FE300512FF4003C0036004B2FD800312F992FD22F53004C00D32F9A00112F7400C42ED62E602F8300402FA32F12001D2FBD2FC62F432EE000F22F8C2FDF00A12FC1012A003B2FCD0010006000C400280085006B004B009C002D2F81006500E22FE22F852F3400592FED002B005100F9005B00110117007A2FD12FA7013A2F1F2EEB007B2F1B2FFD011C0105002B2FCF2F9D007C003200AE00D400AD2F6D2F7D2F922F0D0048007C004700680090011A2F832ED00084003500372FB400552F2201902F602F172FE000162EE92EF801892F9E009300752F3100592F812F3A2FE8015F003D000F2F9100782F0F2F5E2FD1009D2F7600482F942EA72FCA2FA52F4C00E201692F9F00F42EE800E5000A01032FE80077004400A22FA2002A006500442F3F009A008500F62F41004C2FCA011A2FC72FFD2FBE00F70023007E2F0100052FF5001600032FA92FF12F9A00732F47005400E300F62E712F2A0068006C2F76013200ED00F32F942FC32F782F9A2FBB003101892FE82F862F632F232FF82F460168000800752FD000EB00B02F6100D92FA6002F2FB62F780129002C2F7E00872FF12FC92F2000ED2FD40052005D000A2FA72EF101352F4300342F7500C600742FC62FBD2FF02FEC2FC42F922FA900812F5D00842F842EE8013F0127000F006A2EE1008300F800D40078002800E2003700302F402E872FED2DE62EF62FFA2FC52FE82F8F2FE92FE32F182F41")
        salt = sm[2:2+40]
        msg = sm[2+40:2+40+mlen]
        enc_s = sm[2+40+mlen:]
        n = 512
        q = 12289

        pk = PublicKey.from_bytes(pk)
        s1 = decode16(enc_s[1:], 1025, n)
        # Compute s0 and normalize its coefficients in (-q/2, q/2]
        hashed = Poly(pk.hash_to_point(n, salt, msg, xof = KeccakPRNG), q)
        s1 = Poly(s1, q)
        poly_pk =Poly(pk.pk, q)
        s0 = hashed - s1 * poly_pk
        s0 = [(coef + (q >> 1)) % q - (q >> 1) for coef in s0.coeffs]
        s1 = [(coef + (q >> 1)) % q - (q >> 1) for coef in s1.coeffs]

        # Check that the (s0, s1) is short
        norm_sign = sum(coef ** 2 for coef in s0+s1)
        if norm_sign > pk.signature_bound:
            print("Squared norm of signature is too large:", norm_sign)
            print(False)
        print(True)
        # self.assertTrue(pk.verify(msg, sig, xof=KeccakPRNG))

